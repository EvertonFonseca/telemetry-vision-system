# Pacotes
library(dplyr)
library(lubridate)
library(jsonlite)
library(ggplot2)

#-------------------------------------------
# 1) Preparar dados: extrair estado e durações
#-------------------------------------------
prepare_states <- function(df, end_time = NULL) {
  stopifnot(all(c("DATA_OC","DT_HR_LOCAL","CD_ID_OBJETO") %in% names(df)))

  # garantir datetime
  df <- df |> 
    mutate(DT_HR_LOCAL = ymd_hms(DT_HR_LOCAL, quiet = TRUE))

  # extrair "estado" do JSON
  df <- df |> 
    mutate(estado = vapply(
      DATA_OC,
      function(x) tryCatch(fromJSON(x)$estado, error = function(e) NA_character_),
      FUN.VALUE = character(1)
    ))

  # ordenar e calcular next_time e duração (em segundos)
  df <- df |> 
    arrange(CD_ID_OBJETO, DT_HR_LOCAL) |> 
    group_by(CD_ID_OBJETO) |> 
    mutate(
      next_time = lead(DT_HR_LOCAL),
      next_time = if_else(is.na(next_time),
                          coalesce(end_time, DT_HR_LOCAL), # se não passar end_time, fica 0s no último
                          next_time),
      dur_secs  = as.numeric(difftime(next_time, DT_HR_LOCAL, units = "secs"))
    ) %>%
    ungroup()

  # remove durações negativas/NA (se houver)
  df |> filter(!is.na(dur_secs), dur_secs >= 0)
}

#-------------------------------------------
# 2) Plot de barras: tempo total por estado
#-------------------------------------------
plot_barras_tempo_por_estado <- function(df_prepared) {
  agg <- df_prepared |>
    group_by(estado) |>
    summarise(dur_mins = sum(dur_secs)/60, .groups = "drop") %>%
    arrange(desc(dur_mins))

  ggplot(agg, aes(x = reorder(estado, -dur_mins), y = dur_mins)) +
    geom_col() +
    geom_text(aes(label = sprintf("%.2f min", dur_mins)), vjust = -0.3, size = 3.5) +
    labs(title = "Tempo total por estado",
         x = "Estado", y = "Tempo (min)") +
    theme_minimal() +
    expand_limits(y = 0)
}

#-------------------------------------------
# 3) Timeline: intervalos por estado
#   - Faceta por objeto se houver mais de um
#-------------------------------------------
plot_timeline_estados <- function(df_prepared) {
  # usa cada linha como um segmento [DT_HR_LOCAL, next_time]
  ggplot(df_prepared) +
    geom_segment(aes(x = DT_HR_LOCAL, xend = next_time,
                     y = estado, yend = estado),
                 linewidth = 6, lineend = "butt") +
    scale_x_datetime(expand = expansion(mult = c(0.01, 0.03))) +
    labs(title = "Timeline de estados",
         x = "Tempo", y = "Estado") +
    theme_minimal() +
    facet_wrap(~ CD_ID_OBJETO, scales = "free_x", ncol = 1)
}

#-------------------------------------------
# EXEMPLO DE USO com os dados do seu print
# (troque por seu data.frame/consulta ao BD)
#-------------------------------------------
df_print <- tibble::tibble(
  CD_ID_OC      = 1:5,
  DATA_OC       = c(
    '{"maquina":"Corte-Prensa","estado":"stop","bobina":"on","visivel":1}',
    '{"maquina":"Corte-Prensa","estado":"stop","bobina":"on","visivel":1}',
    '{"maquina":"Corte-Prensa","estado":"stop","bobina":"off","visivel":1}',
    '{"maquina":"Corte-Prensa","estado":"operation","bobina":"on","visivel":1}',
    '{"maquina":"Corte-Prensa","estado":"operation","bobina":"on","visivel":1}'
  ),
  CD_ID_OBJETO  = 6L,
  DT_HR_LOCAL   = c("2025-10-07 16:35:48","2025-10-07 16:40:02",
                    "2025-10-07 16:40:06","2025-10-07 16:40:09",
                    "2025-10-07 16:40:12")
)

# Se você souber o horário de fim do período, passe em end_time.
# Se não passar, o último intervalo terá 0s (ou ajuste manualmente).
prep <- prepare_states(df_print, end_time = ymd_hms("2025-10-07 16:40:15"))

p1 <- plot_barras_tempo_por_estado(prep)
p2 <- plot_timeline_estados(prep)

p1
p2
